"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketFlagsT = exports.SocketFlags = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */
const flatbuffers = require("flatbuffers");
class SocketFlags {
    bb = null;
    bb_pos = 0;
    __init(i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    }
    static getRootAsSocketFlags(bb, obj) {
        return (obj || new SocketFlags()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSocketFlags(bb, obj) {
        bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new SocketFlags()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    ipv6Only() {
        const offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    udpReusePort() {
        const offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startSocketFlags(builder) {
        builder.startObject(2);
    }
    static addIpv6Only(builder, ipv6Only) {
        builder.addFieldInt8(0, +ipv6Only, +false);
    }
    static addUdpReusePort(builder, udpReusePort) {
        builder.addFieldInt8(1, +udpReusePort, +false);
    }
    static endSocketFlags(builder) {
        const offset = builder.endObject();
        return offset;
    }
    static createSocketFlags(builder, ipv6Only, udpReusePort) {
        SocketFlags.startSocketFlags(builder);
        SocketFlags.addIpv6Only(builder, ipv6Only);
        SocketFlags.addUdpReusePort(builder, udpReusePort);
        return SocketFlags.endSocketFlags(builder);
    }
    unpack() {
        return new SocketFlagsT(this.ipv6Only(), this.udpReusePort());
    }
    unpackTo(_o) {
        _o.ipv6Only = this.ipv6Only();
        _o.udpReusePort = this.udpReusePort();
    }
}
exports.SocketFlags = SocketFlags;
class SocketFlagsT {
    ipv6Only;
    udpReusePort;
    constructor(ipv6Only = false, udpReusePort = false) {
        this.ipv6Only = ipv6Only;
        this.udpReusePort = udpReusePort;
    }
    pack(builder) {
        return SocketFlags.createSocketFlags(builder, this.ipv6Only, this.udpReusePort);
    }
}
exports.SocketFlagsT = SocketFlagsT;
